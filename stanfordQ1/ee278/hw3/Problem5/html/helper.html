
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>helper</title><meta name="generator" content="MATLAB 8.4"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2014-10-15"><meta name="DC.source" content="helper.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h2>Contents</h2><div><ul><li><a href="#1">Read image data in from files</a></li><li><a href="#2">Compute Covariance Matrix, Eigenvalues, and Eigenvectors</a></li><li><a href="#3">Part B</a></li><li><a href="#4">Part C</a></li><li><a href="#5">Part D</a></li></ul></div><h2>Read image data in from files<a name="1"></a></h2><pre class="codeinput">clear;
digit0 = readData(<span class="string">'hw3-data/digit0/'</span>);
digit2 = readData(<span class="string">'hw3-data/digit2/'</span>);
</pre><h2>Compute Covariance Matrix, Eigenvalues, and Eigenvectors<a name="2"></a></h2><p>I calculate the covariance matrix the same way that we have in question 4b). Please look at the function compute.m to see exactly how this is computed.</p><pre class="codeinput">[mean0, cov0, eigVec0, eigVal0] = compute(digit0);
[mean2, cov2, eigVec2, eigVal2] = compute(digit2);
</pre><h2>Part B<a name="3"></a></h2><pre class="codeinput">figure;
subplot(2,6,1); imshow(reshape(eigVec0(:,1),28,28), []);
subplot(2,6,2); imshow(reshape(eigVec0(:,2),28,28), []);
subplot(2,6,3); imshow(reshape(eigVec0(:,3),28,28), []);
title(<span class="string">'First 6 Eigenvectors for Digit 0'</span>);
subplot(2,6,4); imshow(reshape(eigVec0(:,4),28,28), []);
subplot(2,6,5); imshow(reshape(eigVec0(:,5),28,28), []);
subplot(2,6,6); imshow(reshape(eigVec0(:,6),28,28), []);

subplot(2,6,7); imshow(reshape(eigVec2(:,1),28,28), []);
subplot(2,6,8); imshow(reshape(eigVec2(:,2),28,28), []);
subplot(2,6,9); imshow(reshape(eigVec2(:,3),28,28), []);
title(<span class="string">'First 6 eigenvectors for Digit 2'</span>);
subplot(2,6,10); imshow(reshape(eigVec2(:,4),28,28), []);
subplot(2,6,11); imshow(reshape(eigVec2(:,5),28,28), []);
subplot(2,6,12); imshow(reshape(eigVec2(:,6),28,28), []);
</pre><img vspace="5" hspace="5" src="helper_01.png" alt=""> <h2>Part C<a name="4"></a></h2><p>It seems that these eigenvectors are a mix of the eigenvectors of digit 0 and digit 2. You can clearly see both O's and 2's showing themselves in the eigenvectors of the mix of the digits. Each 0 and 2 showing itself in these eigenvectors are distorted where the eigenvectors of 0 and 2 interest. This makes sense because at those pixel locations the the individual covariance matrices of digits 0 and 2 both are non-zero.</p><pre class="codeinput">figure;
digitConcat = [digit0 digit2];
[meanC, covC, eigVecC, eigValC] = compute(digitConcat);
subplot(1,6,1); imshow(reshape(eigVecC(:,1),28,28), []);
subplot(1,6,2); imshow(reshape(eigVecC(:,2),28,28), []);
subplot(1,6,3); imshow(reshape(eigVecC(:,3),28,28), []);
title(<span class="string">'First 6 Eigenvectors for concatenated Digits'</span>);
subplot(1,6,4); imshow(reshape(eigVecC(:,4),28,28), []);
subplot(1,6,5); imshow(reshape(eigVecC(:,5),28,28), []);
subplot(1,6,6); imshow(reshape(eigVecC(:,6),28,28), []);
</pre><img vspace="5" hspace="5" src="helper_02.png" alt=""> <h2>Part D<a name="5"></a></h2><p>We can see that the "dimensionality" of the data is much less than 784 implied by the 784 eigenvectors. We clearly see that not all of the eigenvalues are the same value. In fact, the first fifty or so eigenvalues are orders of magnitude larger than the remaining 700+. Because the eigenvaules roughly dictate how influential each eigenvector is, those 50 eigenvalues, and corresponding eigenvectors, essentially dictate the "effective" dimensionality of the problem. These 50 eigenvalues, and corresponding eigenvectors, capture the majority of the data stored by the covariance matrices of the images of digits 0 and 2.</p><p>This observation is a very convenient one when approaching feature selection for the recognition of digits. It essentially shows us that we do not need to work with each and every eigenvector and eigenvalue. Only finding the features parallel to the eigenvectors with the highest eigenvalues will be sufficient in recognizing digits. They will be sufficient in differentiating between digits. Of course, this sacrifices accuracy, but only slightly. The benefits incurred by this much smaller problem include a large computational speedup and reduction of storage necessary.</p><pre class="codeinput">lambda0 = diag(eigVal0);
lambda2 = diag(eigVal2);
lambdaC = diag(eigValC);
figure; hold;
plot(1:784, real(lambda0), <span class="string">'*'</span>);
plot(1:784, real(lambda2), <span class="string">'x'</span>);
plot(1:784, real(lambdaC), <span class="string">'o'</span>);
title(<span class="string">'Plot of Eigenvalues'</span>);
legend(<span class="string">'Digit 0'</span>, <span class="string">'Digit 2'</span>, <span class="string">'Combined Digits'</span>, <span class="string">'Location'</span>, <span class="string">'NorthEast'</span>);

figure;hold;
plot(1:20, real(lambda0(1:20)), <span class="string">'*'</span>);
plot(1:20, real(lambda2(1:20)), <span class="string">'x'</span>);
plot(1:20, real(lambdaC(1:20)), <span class="string">'o'</span>);
title(<span class="string">'Plot of the last 10 Eigenvalues'</span>);
legend(<span class="string">'Digit 0'</span>, <span class="string">'Digit 2'</span>, <span class="string">'Combined Digits'</span>, <span class="string">'Location'</span>, <span class="string">'NorthEast'</span>);
</pre><pre class="codeoutput">Current plot held
Current plot held
</pre><img vspace="5" hspace="5" src="helper_03.png" alt=""> <img vspace="5" hspace="5" src="helper_04.png" alt=""> <p class="footer"><br><a href="http://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2014b</a><br></p></div><!--
##### SOURCE BEGIN #####
%% Read image data in from files
clear;
digit0 = readData('hw3-data/digit0/');
digit2 = readData('hw3-data/digit2/');

%% Compute Covariance Matrix, Eigenvalues, and Eigenvectors
% I calculate the covariance matrix the same way that we have in question
% 4b). Please look at the function compute.m to see exactly how this is
% computed.

[mean0, cov0, eigVec0, eigVal0] = compute(digit0);
[mean2, cov2, eigVec2, eigVal2] = compute(digit2);

%% Part B
figure; 
subplot(2,6,1); imshow(reshape(eigVec0(:,1),28,28), []);
subplot(2,6,2); imshow(reshape(eigVec0(:,2),28,28), []); 
subplot(2,6,3); imshow(reshape(eigVec0(:,3),28,28), []);
title('First 6 Eigenvectors for Digit 0');
subplot(2,6,4); imshow(reshape(eigVec0(:,4),28,28), []); 
subplot(2,6,5); imshow(reshape(eigVec0(:,5),28,28), []);
subplot(2,6,6); imshow(reshape(eigVec0(:,6),28,28), []);

subplot(2,6,7); imshow(reshape(eigVec2(:,1),28,28), []);
subplot(2,6,8); imshow(reshape(eigVec2(:,2),28,28), []); 
subplot(2,6,9); imshow(reshape(eigVec2(:,3),28,28), []);
title('First 6 eigenvectors for Digit 2');
subplot(2,6,10); imshow(reshape(eigVec2(:,4),28,28), []); 
subplot(2,6,11); imshow(reshape(eigVec2(:,5),28,28), []);
subplot(2,6,12); imshow(reshape(eigVec2(:,6),28,28), []);

%% Part C
% It seems that these eigenvectors are a mix of the eigenvectors of digit 0
% and digit 2. You can clearly see both O's and 2's showing themselves in
% the eigenvectors of the mix of the digits. Each 0 and 2 showing itself in
% these eigenvectors are distorted where the eigenvectors of 0 and 2
% interest. This makes sense because at those pixel locations the the
% individual covariance matrices of digits 0 and 2 both are non-zero.
figure;
digitConcat = [digit0 digit2];
[meanC, covC, eigVecC, eigValC] = compute(digitConcat);
subplot(1,6,1); imshow(reshape(eigVecC(:,1),28,28), []);
subplot(1,6,2); imshow(reshape(eigVecC(:,2),28,28), []); 
subplot(1,6,3); imshow(reshape(eigVecC(:,3),28,28), []);
title('First 6 Eigenvectors for concatenated Digits');
subplot(1,6,4); imshow(reshape(eigVecC(:,4),28,28), []); 
subplot(1,6,5); imshow(reshape(eigVecC(:,5),28,28), []);
subplot(1,6,6); imshow(reshape(eigVecC(:,6),28,28), []);

%% Part D
% We can see that the "dimensionality" of the data is much less than 784
% implied by the 784 eigenvectors. We clearly see that not all of the
% eigenvalues are the same value. In fact, the first fifty or so eigenvalues
% are orders of magnitude larger than the remaining 700+. Because the
% eigenvaules roughly dictate how influential each eigenvector is, those
% 50 eigenvalues, and corresponding eigenvectors, essentially dictate the
% "effective" dimensionality of the problem. These 50 eigenvalues, and
% corresponding eigenvectors, capture the majority of the data stored by the
% covariance matrices of the images of digits 0 and 2.
%
% This observation is a very convenient one when approaching feature
% selection for the recognition of digits. It essentially shows us that we
% do not need to work with each and every eigenvector and eigenvalue.
% Only finding the features parallel to the eigenvectors with the highest
% eigenvalues will be sufficient in recognizing digits. They will be 
% sufficient in differentiating between digits. Of course, this sacrifices
% accuracy, but only slightly. The benefits incurred by this much smaller
% problem include a large computational speedup and reduction of storage
% necessary. 
lambda0 = diag(eigVal0);
lambda2 = diag(eigVal2);
lambdaC = diag(eigValC);
figure; hold;
plot(1:784, real(lambda0), '*');
plot(1:784, real(lambda2), 'x');
plot(1:784, real(lambdaC), 'o');
title('Plot of Eigenvalues');
legend('Digit 0', 'Digit 2', 'Combined Digits', 'Location', 'NorthEast');

figure;hold;
plot(1:20, real(lambda0(1:20)), '*');
plot(1:20, real(lambda2(1:20)), 'x');
plot(1:20, real(lambdaC(1:20)), 'o');
title('Plot of the last 10 Eigenvalues');
legend('Digit 0', 'Digit 2', 'Combined Digits', 'Location', 'NorthEast');

##### SOURCE END #####
--></body></html>